"""
Barnacle CLI (MVP)

Current focus:
- Validate that a IIIF Presentation 2.1 manifest conforms to the expectations
  of Barnacle's MVP pipeline (Lapidus volumes generated by Figgy).
"""

from __future__ import annotations

import json
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Iterable

import httpx
import typer

app = typer.Typer(add_completion=False, help="Barnacle MVP tooling")

DEFAULT_IIIF_SIZE = "!3000,3000"  # long-side constraint; good OCR/throughput tradeoff
DEFAULT_IIIF_FORMAT = "jpg"
DEFAULT_IIIF_QUALITY = "default"
DEFAULT_IIIF_REGION = "full"
DEFAULT_IIIF_ROTATION = "0"


@dataclass(frozen=True)
class ValidationIssue:
    path: str
    message: str


def _is_url(s: str) -> bool:
    return s.startswith("http://") or s.startswith("https://")


def fetch_manifest(url: str) -> dict[str, Any]:
    with httpx.Client(timeout=10.0, follow_redirects=True) as client:
        resp = client.get(url)
        resp.raise_for_status()
        return resp.json()


def load_manifest(path_or_url: str) -> dict[str, Any]:
    """
    Load a manifest from a local path or a URL.

    - If path_or_url looks like http(s), fetch via httpx.
    - Otherwise, treat as a filesystem path and parse JSON.
    """
    if _is_url(path_or_url):
        return fetch_manifest(path_or_url)

    p = Path(path_or_url).expanduser()
    try:
        return json.loads(p.read_text(encoding="utf-8"))
    except FileNotFoundError as e:
        raise typer.BadParameter(f"File not found: {p}") from e
    except json.JSONDecodeError as e:
        raise typer.BadParameter(f"Invalid JSON in file: {p} ({e})") from e


def iiif_image_url(
    service_id: str,
    *,
    region: str = DEFAULT_IIIF_REGION,
    size: str = DEFAULT_IIIF_SIZE,
    rotation: str = DEFAULT_IIIF_ROTATION,
    quality: str = DEFAULT_IIIF_QUALITY,
    fmt: str = DEFAULT_IIIF_FORMAT,
) -> str:
    """
    Construct an IIIF Image API URL from a service @id.

    Assumes service_id is the base Image API service URI (as found in manifest):
        {service_id}/{region}/{size}/{rotation}/{quality}.{fmt}

    We intentionally do NOT try to "normalize" service_id beyond trimming
    trailing slashes.
    """
    base = service_id.rstrip("/")
    return f"{base}/{region}/{size}/{rotation}/{quality}.{fmt}"


def iter_canvases_v2(manifest: dict[str, Any]) -> Iterable[dict[str, Any]]:
    """MVP traversal helper: Manifest -> sequences[*] -> canvases[*]."""
    for seq in manifest.get("sequences", []) or []:
        for canvas in seq.get("canvases", []) or []:
            yield canvas


def _first_image_service_obj(canvas: dict[str, Any]) -> dict[str, Any] | None:
    """
    Best-effort extraction of the first IIIF Image API service object from a canvas.
    """
    images = canvas.get("images") or []
    if not images or not isinstance(images, list):
        return None

    anno = images[0]
    if not isinstance(anno, dict):
        return None

    resource = anno.get("resource")
    if not isinstance(resource, dict):
        return None

    service = resource.get("service")
    if isinstance(service, dict):
        return service
    if isinstance(service, list) and service and isinstance(service[0], dict):
        return service[0]

    return None


def validate_manifest_v2(manifest: dict[str, Any]) -> list[ValidationIssue]:
    """
    Validate the minimal expectations for the MVP pipeline.

    Deliberately narrow:
    - traversal and image URL resolution for OCR
    - NOT a full IIIF Presentation 2.1 validator.
    """
    issues: list[ValidationIssue] = []

    def err(path: str, message: str) -> None:
        issues.append(ValidationIssue(path=path, message=message))

    # Basic identity
    t = manifest.get("@type")
    if t is None:
        err("@type", "Missing @type; expected 'sc:Manifest'.")
    elif t != "sc:Manifest":
        err("@type", f"Unexpected @type={t!r}; expected 'sc:Manifest' (Presentation 2.x).")

    if "@id" not in manifest:
        err("@id", "Missing @id (manifest identifier).")

    # sequences / canvases
    sequences = manifest.get("sequences")
    if not isinstance(sequences, list) or not sequences:
        err("sequences", "Missing or empty sequences[]; expected at least one sequence.")
        return issues  # nothing more to traverse safely

    canvas_count = 0
    for c_i, canvas in enumerate(iter_canvases_v2(manifest)):
        canvas_count += 1
        if not isinstance(canvas, dict):
            err(f"sequences[*].canvases[{c_i}]", "Canvas is not an object.")
            continue

        if "@id" not in canvas:
            err(f"sequences[*].canvases[{c_i}].@id", "Canvas missing @id.")

        images = canvas.get("images")
        if not isinstance(images, list) or not images:
            err(f"canvas[{c_i}].images", "Canvas missing images[] (expected image annotation).")
            continue

        service_obj = _first_image_service_obj(canvas)
        if service_obj is None:
            err(
                f"canvas[{c_i}].images[0].resource.service",
                "Image resource missing service (IIIF Image API).",
            )
            continue

        if "@id" not in service_obj:
            err(
                f"canvas[{c_i}].images[0].resource.service.@id",
                "Service missing @id (base Image API URI).",
            )

    if canvas_count == 0:
        err("sequences[*].canvases", "No canvases found in any sequence.")

    return issues


@app.command("validate")
def validate_cmd(
    manifest: str = typer.Argument(..., help="Manifest JSON path or URL"),
) -> None:
    """Validate a IIIF Presentation 2.x manifest against MVP expectations."""
    m = load_manifest(manifest)
    issues = validate_manifest_v2(m)

    if issues:
        typer.echo(f"❌ Validation failed: {len(issues)} issue(s)\n")
        for i, issue in enumerate(issues, start=1):
            typer.echo(f"{i:>3}. {issue.path}: {issue.message}")
        raise typer.Exit(code=2)

    typer.echo("✅ Validation passed (MVP expectations).")


@app.command("sample-image-url")
def sample_image_url_cmd(
    manifest: str = typer.Argument(..., help="Manifest JSON path or URL"),
    size: str = typer.Option(DEFAULT_IIIF_SIZE, help="IIIF size parameter"),
    fmt: str = typer.Option(DEFAULT_IIIF_FORMAT, help="IIIF format (e.g., jpg, png)"),
    quality: str = typer.Option(DEFAULT_IIIF_QUALITY, help="IIIF quality (e.g., default)"),
    region: str = typer.Option(DEFAULT_IIIF_REGION, help="IIIF region (e.g., full)"),
    rotation: str = typer.Option(DEFAULT_IIIF_ROTATION, help="IIIF rotation (e.g., 0)"),
) -> None:
    """Print a sample IIIF Image API URL derived from the manifest."""
    m = load_manifest(manifest)

    for canvas in iter_canvases_v2(m):
        service_obj = _first_image_service_obj(canvas)
        if not service_obj:
            continue
        service_id = service_obj.get("@id")
        if not isinstance(service_id, str) or not service_id:
            continue

        url = iiif_image_url(
            service_id,
            size=size,
            fmt=fmt,
            quality=quality,
            region=region,
            rotation=rotation,
        )
        typer.echo(url)
        raise typer.Exit(code=0)

    typer.echo("Could not find an Image API service @id in the manifest.", err=True)
    raise typer.Exit(code=2)


def main() -> None:
    app()


if __name__ == "__main__":
    main()
