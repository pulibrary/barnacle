"""
Barnacle CLI (MVP)

Current focus:
- Validate that a IIIF Presentation 2.1 manifest conforms to the expectations
  of Barnacle's MVP pipeline (Lapidus volumes generated by Figgy).
"""

from __future__ import annotations

from csv import DictReader
import json
import re
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Iterable

import hashlib
import os
import subprocess
import tempfile
import time
from datetime import datetime, timezone

import httpx
import typer
import logging

from barnacle.ocr import KrakenBackend

app = typer.Typer(add_completion=False, help="Barnacle MVP tooling")

DEFAULT_IIIF_SIZE = "!3000,3000"  # long-side constraint; good OCR/throughput tradeoff
DEFAULT_IIIF_FORMAT = "jpg"
DEFAULT_IIIF_QUALITY = "default"
DEFAULT_IIIF_REGION = "full"
DEFAULT_IIIF_ROTATION = "0"

class JsonFormatter(logging.Formatter):
    """Simple JSON formatter for structured logs."""
    def format(self, record: logging.LogRecord) -> str:
        payload: dict[str, Any] = {
            "ts": datetime.now(timezone.utc).isoformat(),
            "level": record.levelname,
            "msg": record.getMessage(),
            "logger": record.name,
        }
        # Include any custom attributes passed via `extra=`.
        reserved = {
            "name","msg","args","levelname","levelno","pathname","filename","module",
            "exc_info","exc_text","stack_info","lineno","funcName","created","msecs",
            "relativeCreated","thread","threadName","processName","process",
        }
        for k, v in record.__dict__.items():
            if k in reserved or k.startswith("_"):
                continue
            try:
                json.dumps(v)
                payload[k] = v
            except TypeError:
                payload[k] = repr(v)
        if record.exc_info:
            payload["exc_info"] = self.formatException(record.exc_info)
        return json.dumps(payload, ensure_ascii=False)


def setup_logging(level: str) -> logging.Logger:
    logger = logging.getLogger("barnacle")
    logger.setLevel(getattr(logging, level.upper(), logging.INFO))
    handler = logging.StreamHandler()
    handler.setFormatter(JsonFormatter())
    logger.handlers[:] = [handler]
    logger.propagate = False
    return logger


LOGGER = logging.getLogger("barnacle")


@dataclass(frozen=True)
class ValidationIssue:
    path: str
    message: str


def _is_url(s: str) -> bool:
    return s.startswith("http://") or s.startswith("https://")


def fetch_manifest(url: str) -> dict[str, Any]:
    with httpx.Client(timeout=10.0, follow_redirects=True) as client:
        resp = client.get(url)
        resp.raise_for_status()
        return resp.json()


def load_manifest(path_or_url: str) -> dict[str, Any]:
    """
    Load a manifest from a local path or a URL.

    - If path_or_url looks like http(s), fetch via httpx.
    - Otherwise, treat as a filesystem path and parse JSON.
    """
    if _is_url(path_or_url):
        return fetch_manifest(path_or_url)

    p = Path(path_or_url).expanduser()
    try:
        return json.loads(p.read_text(encoding="utf-8"))
    except FileNotFoundError as e:
        raise typer.BadParameter(f"File not found: {p}") from e
    except json.JSONDecodeError as e:
        raise typer.BadParameter(f"Invalid JSON in file: {p} ({e})") from e




def is_collection_v2(obj: dict[str, Any]) -> bool:
    return obj.get("@type") == "sc:Collection"


def is_manifest_v2(obj: dict[str, Any]) -> bool:
    return obj.get("@type") == "sc:Manifest"


def iter_manifest_targets(path_or_url: str) -> Iterable[tuple[str, dict[str, Any]]]:
    """
    Yields (manifest_id, manifest_json) pairs.

    If the root JSON is an sc:Manifest, yields exactly that one.
    If the root JSON is an sc:Collection, yields each member manifest referenced in `manifests[*].@id`.

    Note: This intentionally does not recurse into nested collections for the MVP.
    """
    root = load_manifest(path_or_url)
    if is_manifest_v2(root):
        yield (path_or_url, root)
        return

    if not is_collection_v2(root):
        raise typer.BadParameter(
            f"Root @type must be sc:Manifest or sc:Collection (got {root.get('@type')!r})."
        )

    manifests = root.get("manifests") or []
    if not isinstance(manifests, list) or not manifests:
        raise typer.BadParameter("Collection has no `manifests` list to process.")

    for i, m in enumerate(manifests):
        if not isinstance(m, dict) or "@id" not in m:
            raise typer.BadParameter(f"Collection.manifests[{i}] missing @id.")
        manifest_id = str(m["@id"])
        yield (manifest_id, load_manifest(manifest_id))


def _sha1(s: str) -> str:
    return hashlib.sha1(s.encode("utf-8")).hexdigest()



def page_key(*, manifest_id: str, canvas_id: str, model: str, fmt: str, size: str, quality: str, region: str, rotation: str) -> str:
    """Stable identifier for a single OCR result for resume-safe runs."""
    return "|".join([manifest_id, canvas_id, model, fmt, size, quality, region, rotation])


def load_processed_keys(out_path: Path) -> set[str]:
    """Reads an existing JSONL output file and returns all recorded page_key values."""
    processed: set[str] = set()
    if not out_path.exists():
        return processed
    try:
        with out_path.open("r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue
                try:
                    rec = json.loads(line)
                except json.JSONDecodeError:
                    # Ignore truncated/invalid lines (e.g., partial last line).
                    continue
                k = rec.get("page_key")
                if isinstance(k, str):
                    processed.add(k)
    except OSError:
        # If the file cannot be read for some reason, fall back to reprocessing.
        return set()
    return processed
def fetch_bytes(url: str, *, timeout: float = 30.0) -> bytes:
    with httpx.Client(timeout=timeout, follow_redirects=True) as client:
        resp = client.get(url)
        resp.raise_for_status()
        return resp.content


def iiif_image_url(
    service_id: str,
    *,
    region: str = DEFAULT_IIIF_REGION,
    size: str = DEFAULT_IIIF_SIZE,
    rotation: str = DEFAULT_IIIF_ROTATION,
    quality: str = DEFAULT_IIIF_QUALITY,
    fmt: str = DEFAULT_IIIF_FORMAT,
) -> str:
    """
    Construct an IIIF Image API URL from a service @id.

    Assumes service_id is the base Image API service URI (as found in manifest):
        {service_id}/{region}/{size}/{rotation}/{quality}.{fmt}

    We intentionally do NOT try to "normalize" service_id beyond trimming
    trailing slashes.
    """
    base = service_id.rstrip("/")
    return f"{base}/{region}/{size}/{rotation}/{quality}.{fmt}"


def iter_canvases_v2(manifest: dict[str, Any]) -> Iterable[dict[str, Any]]:
    """MVP traversal helper: Manifest -> sequences[*] -> canvases[*]."""
    for seq in manifest.get("sequences", []) or []:
        for canvas in seq.get("canvases", []) or []:
            yield canvas


def _first_image_service_obj(canvas: dict[str, Any]) -> dict[str, Any] | None:
    """
    Best-effort extraction of the first IIIF Image API service object from a canvas.
    """
    images = canvas.get("images") or []
    if not images or not isinstance(images, list):
        return None

    anno = images[0]
    if not isinstance(anno, dict):
        return None

    resource = anno.get("resource")
    if not isinstance(resource, dict):
        return None

    service = resource.get("service")
    if isinstance(service, dict):
        return service
    if isinstance(service, list) and service and isinstance(service[0], dict):
        return service[0]

    return None


def validate_collection_v2(collection: dict[str, Any]) -> list[ValidationIssue]:
    """
    Validate the minimal expectations for a IIIF Collection (Presentation 2.x).

    Checks:
    - Collection has proper @type
    - Collection has @id
    - Collection has manifests[] array
    - Each manifest reference has @id
    """
    issues: list[ValidationIssue] = []

    def err(path: str, message: str) -> None:
        issues.append(ValidationIssue(path=path, message=message))

    # Basic identity
    t = collection.get("@type")
    if t is None:
        err("@type", "Missing @type; expected 'sc:Collection'.")
    elif t != "sc:Collection":
        err("@type", f"Unexpected @type={t!r}; expected 'sc:Collection' (Presentation 2.x).")

    if "@id" not in collection:
        err("@id", "Missing @id (collection identifier).")

    # manifests array
    manifests = collection.get("manifests")
    if not isinstance(manifests, list):
        err("manifests", "Missing or invalid manifests[]; expected a list of manifest references.")
        return issues  # nothing more to validate safely

    if not manifests:
        err("manifests", "Empty manifests[]; expected at least one manifest reference.")

    for i, m in enumerate(manifests):
        if not isinstance(m, dict):
            err(f"manifests[{i}]", "Manifest reference is not an object.")
            continue
        if "@id" not in m:
            err(f"manifests[{i}].@id", "Manifest reference missing @id.")

    return issues


def validate_manifest_v2(manifest: dict[str, Any]) -> list[ValidationIssue]:
    """
    Validate the minimal expectations for a IIIF Manifest (Presentation 2.x) in the MVP pipeline.

    Deliberately narrow:
    - traversal and image URL resolution for OCR
    - NOT a full IIIF Presentation 2.1 validator.

    Note: For Collections, use validate_collection_v2() instead.
    """
    issues: list[ValidationIssue] = []

    def err(path: str, message: str) -> None:
        issues.append(ValidationIssue(path=path, message=message))

    # Basic identity
    t = manifest.get("@type")
    if t is None:
        err("@type", "Missing @type; expected 'sc:Manifest'.")
    elif t != "sc:Manifest":
        err("@type", f"Unexpected @type={t!r}; expected 'sc:Manifest' (Presentation 2.x).")

    if "@id" not in manifest:
        err("@id", "Missing @id (manifest identifier).")

    # sequences / canvases
    sequences = manifest.get("sequences")
    if not isinstance(sequences, list) or not sequences:
        err("sequences", "Missing or empty sequences[]; expected at least one sequence.")
        return issues  # nothing more to traverse safely

    canvas_count = 0
    for c_i, canvas in enumerate(iter_canvases_v2(manifest)):
        canvas_count += 1
        if not isinstance(canvas, dict):
            err(f"sequences[*].canvases[{c_i}]", "Canvas is not an object.")
            continue

        if "@id" not in canvas:
            err(f"sequences[*].canvases[{c_i}].@id", "Canvas missing @id.")

        images = canvas.get("images")
        if not isinstance(images, list) or not images:
            err(f"canvas[{c_i}].images", "Canvas missing images[] (expected image annotation).")
            continue

        service_obj = _first_image_service_obj(canvas)
        if service_obj is None:
            err(
                f"canvas[{c_i}].images[0].resource.service",
                "Image resource missing service (IIIF Image API).",
            )
            continue

        if "@id" not in service_obj:
            err(
                f"canvas[{c_i}].images[0].resource.service.@id",
                "Service missing @id (base Image API URI).",
            )

    if canvas_count == 0:
        err("sequences[*].canvases", "No canvases found in any sequence.")

    return issues


@app.command("validate")
def validate_cmd(
    manifest_or_collection: str = typer.Argument(..., help="Manifest or Collection JSON path or URL"),
) -> None:
    """Validate a IIIF Presentation 2.x manifest or collection against MVP expectations."""
    root = load_manifest(manifest_or_collection)
    all_issues: list[tuple[str, list[ValidationIssue]]] = []

    # If root is a Collection, validate its structure first
    if is_collection_v2(root):
        collection_issues = validate_collection_v2(root)
        if collection_issues:
            all_issues.append((manifest_or_collection, collection_issues))

    # Validate each manifest (works for both single manifests and collections)
    for manifest_id, manifest_json in iter_manifest_targets(manifest_or_collection):
        issues = validate_manifest_v2(manifest_json)
        if issues:
            all_issues.append((manifest_id, issues))

    if all_issues:
        total_issues = sum(len(issues) for _, issues in all_issues)
        typer.echo(f"❌ Validation failed: {total_issues} issue(s) across {len(all_issues)} resource(s)\n")
        for resource_id, issues in all_issues:
            typer.echo(f"\nResource: {resource_id}")
            for i, issue in enumerate(issues, start=1):
                typer.echo(f"  {i:>3}. {issue.path}: {issue.message}")
        raise typer.Exit(code=2)

    typer.echo("✅ Validation passed (MVP expectations).")

@app.command("validate_all")
def validate_all_cmd(
        path_to_csv_file: str = typer.Argument(..., help="Path to Figgy report"),
) -> None:
    """Validate a table of IIIF Presentation 2.x manifests against MVP expectations."""
    with Path(path_to_csv_file).open('r') as csv_file:
        reader:DictReader = DictReader(csv_file)
        for row in reader:
            manifest_url:str = row['manifest_url']
            try:
                m: dict[str, Any] = fetch_manifest(manifest_url)
            except httpx.HTTPError as e:
                typer.echo(f"❌ : Could not access manifest: {e}")
                continue

            issues = validate_manifest_v2(m)
            if issues:
                typer.echo(f"❌ Validation failed: {len(issues)} issue(s)\n")
                for i, issue in enumerate(issues, start=1):
                    typer.echo(f"{i:>3}. {issue.path}: {issue.message}")
            else:
                typer.echo("✅ Validation passed (MVP expectations).")






@app.command("ocr")
def ocr_cmd(
    manifest_or_collection: str = typer.Argument(
        ..., help="IIIF Presentation 2.x manifest or collection JSON path or URL"
    ),
    model: str = typer.Option(
        ..., "--model", help="Kraken model ref: DOI, installed model name, or filesystem path"
    ),
    out: Path = typer.Option(
        ..., "--out", help="Output JSONL path (appends per-page records immediately)"
    ),
    max_pages: int | None = typer.Option(
        None, "--max-pages", help="Optional cap on number of canvases/pages per manifest"
    ),
    cache_dir: Path = typer.Option(
        Path(".barnacle-cache"), "--cache-dir", help="Cache directory for downloaded images"
    ),
    size: str = typer.Option(DEFAULT_IIIF_SIZE, help="IIIF size parameter"),
    fmt: str = typer.Option(DEFAULT_IIIF_FORMAT, help="IIIF format (e.g., jpg, png)"),
    quality: str = typer.Option(DEFAULT_IIIF_QUALITY, help="IIIF quality (e.g., default)"),
    region: str = typer.Option(DEFAULT_IIIF_REGION, help="IIIF region (e.g., full)"),
    rotation: str = typer.Option(DEFAULT_IIIF_ROTATION, help="IIIF rotation (e.g., 0)"),
    source_metadata_id: str | None = typer.Option(
        None, "--source-metadata-id", help="Optional provenance field (CSV column in pipeline mode)"
    ),
    ark: str | None = typer.Option(
        None, "--ark", help="Optional provenance field (CSV column in pipeline mode)"
    ),
    resume: bool = typer.Option(
        True, "--resume/--no-resume", help="Skip pages already present in the output JSONL"
    ),
    log_level: str = typer.Option(
        "INFO", "--log-level", help="Logging verbosity (DEBUG, INFO, WARNING, ERROR)"
    ),
    model_auto_install: bool = typer.Option(
        True, "--model-auto-install/--no-model-auto-install", help="If model looks like a DOI, run `kraken get` first"
    ),
) -> None:
    """
    Runs Kraken OCR over a IIIF v2 manifest (or a v2 collection of manifests) and writes JSONL.

    Example:
        barnacle ocr <manifest-or-collection> --model 10.5281/zenodo.14585602 --out out.jsonl --max-pages 5
    """
    global LOGGER
    LOGGER = setup_logging(log_level)

    backend = KrakenBackend(model_auto_install=model_auto_install, logger=LOGGER)

    out = out.expanduser()
    cache_dir = cache_dir.expanduser()
    img_cache = cache_dir / "images"
    img_cache.mkdir(parents=True, exist_ok=True)

    resolved_model = backend.resolve_model(model)

    processed_keys = load_processed_keys(out) if resume else set()
    if processed_keys:
        LOGGER.info("resume_loaded", extra={"out": str(out), "processed": len(processed_keys)})

    def append_record(rec: dict[str, Any]) -> None:
        out.parent.mkdir(parents=True, exist_ok=True)
        with out.open("a", encoding="utf-8") as f:
            f.write(json.dumps(rec, ensure_ascii=False) + "\n")

    for manifest_id, manifest_json in iter_manifest_targets(manifest_or_collection):
        issues = validate_manifest_v2(manifest_json)
        if issues:
            typer.echo(f"❌ Validation failed for {manifest_id}: {len(issues)} issue(s); skipping.", err=True)
            for i, issue in enumerate(issues, start=1):
                typer.echo(f"{i:>3}. {issue.path}: {issue.message}", err=True)
            continue

        pages_processed = 0
        for c_i, canvas in enumerate(iter_canvases_v2(manifest_json)):
            if max_pages is not None and pages_processed >= max_pages:
                break

            # pull first Image API service id from this canvas
            try:
                service_id = canvas["images"][0]["resource"]["service"]["@id"]
            except Exception:
                typer.echo(f"⚠️  canvas[{c_i}] missing images[0].resource.service.@id; skipping.", err=True)
                continue

            image_url = iiif_image_url(
                service_id,
                region=region,
                size=size,
                rotation=rotation,
                quality=quality,
                fmt=fmt,
            )


            canvas_id = str(canvas.get("@id") or "")
            k = page_key(
                manifest_id=manifest_id,
                canvas_id=canvas_id,
                model=resolved_model,
                fmt=fmt,
                size=size,
                quality=quality,
                region=region,
                rotation=rotation,
            )
            if resume and k in processed_keys:
                LOGGER.info("page_skip", extra={"manifest": manifest_id, "canvas_index": c_i, "page_key": k})
                continue
            # cache download
            cache_key = _sha1(image_url)
            img_path = img_cache / f"{cache_key}.{fmt}"
            if not img_path.exists():
                try:
                    img_bytes = fetch_bytes(image_url)
                except httpx.HTTPError as e:
                    typer.echo(f"❌ Failed to download image: {image_url} ({e}); skipping.", err=True)
                    continue
                img_path.write_bytes(img_bytes)

            t0 = time.perf_counter()
            text_out = backend.ocr_image(img_path, model=resolved_model)
            elapsed_ms = int((time.perf_counter() - t0) * 1000)

            rec = {
                "created_at": datetime.now(timezone.utc).isoformat(),
                "page_key": k,
                "canvas_index": c_i,
                "engine": backend.name,
                "model": {"ref": model, "resolved": resolved_model},
                "manifest_url": manifest_id,
                "canvas_id": canvas.get("@id"),
                "image_url": image_url,
                "elapsed_ms": elapsed_ms,
                "text": text_out,
                "source_metadata_id": source_metadata_id,
                "ark": ark,
            }
            append_record(rec)
            if resume:
                processed_keys.add(k)
            pages_processed += 1
            LOGGER.info("page_done", extra={"manifest": manifest_id, "canvas_index": c_i, "elapsed_ms": elapsed_ms, "text_len": len(text_out), "page_key": k})
            typer.echo(f"✅ {manifest_id} canvas[{c_i}] → appended ({elapsed_ms} ms)")



@app.command("sample-image-url")
def sample_image_url_cmd(
    manifest_or_collection: str = typer.Argument(..., help="Manifest or Collection JSON path or URL"),
    size: str = typer.Option(DEFAULT_IIIF_SIZE, help="IIIF size parameter"),
    fmt: str = typer.Option(DEFAULT_IIIF_FORMAT, help="IIIF format (e.g., jpg, png)"),
    quality: str = typer.Option(DEFAULT_IIIF_QUALITY, help="IIIF quality (e.g., default)"),
    region: str = typer.Option(DEFAULT_IIIF_REGION, help="IIIF region (e.g., full)"),
    rotation: str = typer.Option(DEFAULT_IIIF_ROTATION, help="IIIF rotation (e.g., 0)"),
) -> None:
    """Print a sample IIIF Image API URL derived from the manifest or collection."""
    # Iterate through manifests (handles both single manifests and collections)
    for manifest_id, manifest_json in iter_manifest_targets(manifest_or_collection):
        for canvas in iter_canvases_v2(manifest_json):
            service_obj = _first_image_service_obj(canvas)
            if not service_obj:
                continue
            service_id = service_obj.get("@id")
            if not isinstance(service_id, str) or not service_id:
                continue

            url = iiif_image_url(
                service_id,
                size=size,
                fmt=fmt,
                quality=quality,
                region=region,
                rotation=rotation,
            )
            typer.echo(url)
            raise typer.Exit(code=0)

    typer.echo("Could not find an Image API service @id in any manifest.", err=True)
    raise typer.Exit(code=2)


def main() -> None:
    app()


if __name__ == "__main__":
    main()
